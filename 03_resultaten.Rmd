# Methodologie

## Gebiedsbeschrijving

De getijstuw in Dendermonde bevindt zich op de Zeeschelde, net stroomafwaarts van de samenvloeiing met de Dender.
De stuw maakt deel uit van het getijdengebonden deel van de Schelde en ligt binnen een overstromingsgevoelige zone met een uitgesproken estuarien karakter.
Het omliggende landschap wordt gekenmerkt door brede riviervlaktes, slikken en schorren, en kent sterke wisselingen in waterstand als gevolg van de getijwerking vanuit de Noordzee.
De Zeeschelde is op deze locatie onderhevig aan een semidiurnaal getij, met gemiddeld twee hoogwaters en twee laagwaters per etmaal.
De getijstuw reguleert de getij-invloed stroomopwaarts en laat gecontroleerde doorstroming toe richting het binnenland.
De stuw fungeert als overgangsstructuur tussen het maritiem beïnvloede getijregime en het meer gestabiliseerde waterpeil in de bovenlopen van het riviersysteem.
Aan de bovenstroomse zijde van de stuw geldt een theoretisch streefpeil van **3,82 meter TAW**, dat als referentiepeil wordt gehanteerd voor het waterbeheer in deze zone.
Dit peil zorgt voor een gecontroleerde opstuwing van het water in de richting van de Dender bovenstrooms van Dendermonde.
Het handhaven van dit peil is essentieel voor de werking van de stuw en het algemene peilbeheer in het intergetijdengebied.

Het sluisstuwcomplex van Dendermonde bestaat uit een combinatie van een stuwconstructie, een schutsluis en bijhorende infrastructuur voor waterbeheersing.
Het ontwerp laat een gereguleerde uitwisseling toe tussen de getijdeninvloeden van de Zeeschelde en het bovenstrooms gelegen binnenwaterstelsel van de Dender.

Het complex is opgebouwd uit meerdere functionele zones.
Centraal bevinden zich de doorstroomopeningen van de stuw, geflankeerd door oeverconstructies en geleidewerken.
Deze stuwsecties laten gecontroleerde waterafvoer toe in functie van het getij en het bovenstroomse peilbeheer.
De schutsluis is parallel aan de stuw gelegen en dient voor de doorgang van de scheepvaart.
Ze verbindt het benedenstroomse getijdeel van de Schelde met het hoger gelegen niet-getijgebonden deel van de Dender.

De **doorsnede B–C** toont een typische dwarsdoorsnede door de stuw.
De stuw is uitgevoerd met een betonnen onderbouw en verticale stuwschuiven of segmenten, die hydraulisch bediend worden.
Boven de stuw bevindt zich een stalen bovendorpel waarop de bedieningselementen en brugstructuren rusten.
De waterlijn varieert afhankelijk van de getijstand en de regeling van de stuwsegmenten.
Aan de benedenstroomse zijde is een erosiebeschermingslaag aangebracht om bodemscour ten gevolge van valhoogte en stroming te vermijden.

In de **doorsnede D–E** wordt een langsdoorsnede getoond over een deel van het complex, waarbij zowel de bedieningsconstructie als het waterverloop over de stuw zichtbaar zijn.
Het verschil in waterpeil tussen boven- en benedenstroomse zijde is goed merkbaar, vooral bij laag tij.
De doorsnede illustreert eveneens de integratie van geleidewerken en walkanten, wat belangrijk is voor de geleiding van schepen en voor de hydraulische vormgeving van de instroomzones.

## Onderzoeksluik 1: Analyse en voorbereiding via terreinbezoeken, dataverwerking en overleg

Deze eerste fase richt zich op het verzamelen van relevante informatie en het opbouwen van inzicht in het functioneren en het beheer van de getijdestuw in Dendermonde.
Hierbij wordt zowel gebruik gemaakt van terreinobservaties als van historische data en overleg met betrokken beheerders en experten.

De belangrijkste activiteiten binnen deze deelopdracht zijn:

-   **Terreinbezoeken en overlegmomenten**
    -   Bezoek aan de getijdestuw op de Dijle te Mechelen, waar sinds 2010 een aangepaste ‘vismigratiestand’ gehanteerd wordt (cf. Stevens & Coeck, 2010).
    -   Bezoek aan de getijdestuw op de Dender te Dendermonde.
    -   Doel van deze bezoeken is het documenteren van de werking ter plaatse, het identificeren van technische en operationele kenmerken, en het leren uit praktijkervaringen (do’s en don’ts).
-   **Data-analyse en visualisatie**
    -   Analyse van beschikbare meetreeksen van debieten, op- en afwaartse waterstanden en klepstanden van de stuw in Dendermonde.
    -   Opmaak van grafieken en samenvattende figuren die de relatie tussen debiet, waterstand en klepstand inzichtelijk maken onder verschillende omstandigheden (tij, seizoen, stuwstand).
    -   Analyse van frequentie en duur van potentiële migratievensters.
-   **Overleg met experten en betrokken instanties**
    -   Organisatie van overlegmomenten met specialisten van het Waterbouwkundig Laboratorium (WL) en andere relevante actoren (bv. VMM, De Vlaamse Waterweg).
    -   Doel is het aftoetsen van inzichten, bespreken van knelpunten, en verkennen van technische randvoorwaarden voor aanpassing van het beheer.
-   **Opmaak van een voorstel voor aangepast stuwbeheer**
    -   Formulering van een beheerstrategie die vismigratie faciliteert, rekening houdend met ecologische, hydraulische en nautische randvoorwaarden.
    -   Indien relevant, gebeurt dit naar analogie met het beheer van de Dijlestuw in Mechelen.
    -   Het voorstel wordt besproken en verfijnd in samenwerking met het WL.

## Onderzoeksluik 2: Potentiële bijkomende metingen en schaalmodelstudie

Afhankelijk van de resultaten en aanbevelingen uit deelopdracht 1, kan het nodig blijken om bijkomende metingen uit te voeren of een schaalmodelstudie op te zetten.

Dit tweede onderzoeksluik wordt voorlopig **niet opgenomen in dit rapport**, aangezien de noodzaak en haalbaarheid hiervan eerst met het WL geëvalueerd worden.
Indien beslist wordt om deze stap uit te voeren, kan onderzoeksluik 2 bestaan uit:

-   **Hydraulische terreinmetingen**
    -   Uitvoering van meetcampagnes onder verschillende debietscondities, in samenwerking met het WL.
    -   Metingen van stromingsprofielen, snelheden, en waterstanden op en nabij de stuw.
-   **Schaalmodelonderzoek**
    -   Eventuele opbouw en inzet van een fysiek schaalmodel door het WL.
    -   Analyse van stromingsdynamiek en vispasseerbaarheid onder gecontroleerde omstandigheden.
    -   Gebruik van het schaalmodel om alternatieve stuwinstellingen en beheersstrategieën te testen.

De concrete invulling van dit onderzoeksluik is afhankelijk van de resultaten en aanbevelingen van onderzoeksluik 1, en zal pas worden vastgelegd na overleg met het WL.

```{r}
source("./code/not_functions/libraries.R")
source("./code/functions/estimate_parameters_with_solver_to_optimize_vo.R")
source("./code/functions/find_parameter_combinations_to_optimize_vo.R")
```

```{r}
clean_waterinfo<-function(dir){
  files<-list.files(path=dir,pattern = ".csv")
  for (i in 1:length(files)){
    path<-paste0(dir,files[i])
    file_name<-gsub(".csv","",files[i])
    temp<-read.csv(path,sep=';',skip=7)[,1:2]
    colnames(temp)<-c("date","value")
    temp$loc<-paste(str_split_1(file_name,"_")[1],str_split_1(file_name,"_")[2])
    temp$regio<-str_split_1(file_name,"_")[2]
    temp$var<-tolower(str_split_1(file_name,"_")[3])
    temp$value<-as.numeric(sub(",", ".", temp$value, fixed = TRUE))
    if (i==1){data=temp} else {data=rbind(data,temp)}
  }
  data$date=substr(gsub("T", " ", as.character(data$date)),1,19)
  data$date_brussels = as.POSIXct(data$date,format='%Y-%m-%d %H:%M:%S',tz="Europe/Brussels")
  data$date_utc = data$date_brussels; attr(data$date_utc, "tzone") <- "GMT"
  data=unique(data)
  return(data)
}
```

```{r}
waterinfo<-clean_waterinfo(dir="./data/extern/omgeving/")

waterinfo$regio=factor(waterinfo$regio, levels=c("Dender","Zeeschelde"))
waterinfo$var=factor(waterinfo$var, levels=c("waterpeil","afvoer"))
waterinfo$loc=factor(waterinfo$loc, levels=c("Dendermonde Dender","Dendermonde Opwaarts DVW Dender","Dendermonde Afwaarts DVW tij Zeeschelde","Dendermonde tij Zeeschelde"))
```

```{r tijdreeksenstudieperiode1, fig.height=12, fig.width=10, fig.cap="Overzicht van metingen van waterpeil (m), voor relevante meetstations doorheen de tijd. De stations staan geordend van stroomopwaarts naar stroomafwaarts."}
ggplot(waterinfo %>% dplyr::filter(date_utc>as.POSIXct("2024-01-25 00:00") & date_utc<as.POSIXct("2024-01-29 00:00")), aes(x = date_utc, y = value)) + 
  geom_line() +
  xlab("Datum") + ylab("Waterpeil (meter)") +
  facet_wrap(~ var*loc, ncol = 1, scales="free_y") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  scale_x_datetime(date_labels = "%d-%m %H:%M", date_breaks = "12 hours") + theme_bw()
```

```{r message=FALSE, warning=FALSE}
dir='./data/extern/logboeken/verwerkt_in_excel/2024 Historiek/'
files<-list.files(path=dir)
for (i in 1:length(files)){
  path<-paste0(dir,files[i])
  temp=read_excel(path, sheet = 'Waterbeheersing',skip=15)[,c(4,5,9,10,11)] %>%
    dplyr::filter(!if_all(everything(), is.na))
  if (i==1){s=temp} else {s=rbind(s,temp)}
}

colnames(s)=c("date","time","opwaartswaterpeil","neerwaartswaterpeil","stuw")
s$datetime <- make_datetime(
  year = year(s$date),
  month = month(s$date),
  day = day(s$date),
  hour = hour(s$time),
  min = minute(s$time),
  sec = second(s$time),
  tz = "Europe/Brussels"
)
attr(s$datetime, "tzone") <- "GMT"
s <- s %>% 
  dplyr::select(-date,-time) %>% 
  mutate(    opwaartswaterpeil = as.numeric(gsub(",", ".", opwaartswaterpeil, fixed = TRUE)),
    neerwaartswaterpeil = as.numeric(gsub(",", ".", neerwaartswaterpeil, fixed = TRUE))) %>%
  dplyr::filter(is.na(stuw)==FALSE) %>% 
  mutate(opwaartswaterpeil = opwaartswaterpeil + 1.95,
         neerwaartswaterpeil = neerwaartswaterpeil + 1.95)

t <- s %>%
  mutate(
    hefactie = ifelse((grepl("[A-Za-z]", stuw)), TRUE, FALSE),
    sluice_height   = ifelse(!grepl("[a-zA-Z]", stuw), as.numeric(stuw), NA)/100 + 1.95,
    sluice_opening = ifelse(grepl("[a-zA-Z]", stuw), as.numeric(gsub("[^0-9]", "", stuw))/100, NA),
    sluice_height   = zoo::na.locf(sluice_height, na.rm = FALSE),
    sluice_opening = ifelse(is.na(sluice_opening), 0, sluice_opening), 
    sluice_height = sluice_height + sluice_opening,
    #sluice_opening = zoo::na.locf(sluice_opening, na.rm = FALSE),
    #sluice_height   = ifelse(hefactie == TRUE & sluice_height < sluice_opening + 4.65, sluice_opening + 4.65, sluice_height), 
    #sluice_opening   = ifelse(hefactie == FALSE & sluice_height < sluice_opening + 4.65, 0, sluice_opening),
    datetime = round_date(datetime, unit="5 mins")
  ) %>% 
  select(-stuw) %>%
  complete(datetime = seq(min(datetime), max(datetime), by = "5 min")) %>%
  fill(everything(), .direction = "down")
```

```{r}
data <- waterinfo %>% 
  dplyr::filter(date_utc>as.POSIXct("2024-01-01 00:00") & date_utc<as.POSIXct("2024-05-01 00:00") & var=="waterpeil" & loc %in% c("Dendermonde Opwaarts DVW Dender","Dendermonde Afwaarts DVW tij Zeeschelde")) %>% 
  dplyr::select(date_utc,var,loc,regio,value) %>% 
  mutate(var=paste(var,loc,regio,sep="_")) %>%
  dplyr::select(-loc,-regio) %>% 
  distinct(date_utc, var, .keep_all = TRUE) %>% 
  pivot_wider(names_from = var, values_from = value) %>%
  rename("h_downstream" = "waterpeil_Dendermonde Afwaarts DVW tij Zeeschelde_Zeeschelde",
         "h_upstream" = "waterpeil_Dendermonde Opwaarts DVW Dender_Dender") %>% 
  dplyr::select(date_utc, h_downstream, h_upstream) %>% 
  mutate(h_downstream=h_downstream+1.95,
         h_upstream=h_upstream+1.95) %>%
  left_join(t %>% select(datetime,sluice_height,sluice_opening),by= c("date_utc" = "datetime")) %>%
  drop_na() %>%
  mutate(
    bereikbaar = case_when(
      h_upstream < sluice_height & sluice_opening == 0 ~ "no",
      TRUE ~ "yes"
    ),
    bereikbaar_stroomafwaarts_over_stuw = case_when(
      h_upstream < sluice_height ~ "no",
      TRUE ~ "yes"
    ),
    bereikbaar_stroomopwaarts_over_stuw = case_when(
      h_downstream < sluice_height ~ "no",
      TRUE ~ "yes"
    ),
    bereikbaar_onder_stuw = case_when(
      sluice_opening == 0 ~ "no",
      TRUE ~ "yes"
    )
  )
```

In de volgende secties wordt beschreven hoe de berekeningen gebeuren.
Het spuidebiet (en de geassocieerde stroomsnelheid) van een getijdestuw op basis van metingen om de 5 minuten van het waterpeil boven- en benedenstrooms wordt berekend.\
Er wordt daarbij rekening gehouden met:

1.  **Overstroming** (wanneer water over de stuw stroomt)
2.  **Onderstrooming** (wanneer water onder de stuw stroomt)
3.  **Villemonte-correctie** (voor het corrigeren van ondergedompelde stromingscondities)
4.  **Vrije stroming** (wanneer water ongehinderd kan stromen)

## Overzicht van de berekeningen

### Stroming over de stuw

$$
Q_o = C_e \cdot \frac{2}{3} \cdot b \cdot \sqrt{2g} \cdot h_o^{3/2}
$$ **Waar:** - $Q_o$ = Discharge over the weir/ Debiet over de stuw (m³/s) - $C_e$ = Discharge coefficient/ Debietscoefficiënt (dimensionless/ dimensieloos) - $b$ = Width of the weir/ Breedte van de stuw (m) - $g$ = Gravitational acceleration/ Zwaartekrachtversnelling (9.81 m/s²) - $h_o$ = Head over the weir crest/ Waterhoogte boven de stuwkruin (m)

### Stroming onder de stuw

$$
Q_u = C_d \cdot b \cdot h_u \cdot \sqrt{2g (h_up - h_{down})}
$$ **Waar:** - $Q_u$ = Discharge under the weir/ Debiet onder de stuw (m³/s) - $C_d$ = Discharge coefficient for underflow/ Debietscoefficiënt voor onderstroom (dimensionless/ dimensieloos) - $h_u$ = Height of weir opening/ Hoogte stuw opening (m) - $h_up$ = Upstream water level/ Stroomopwaarts waterpeil (m) - $h_{down}$ = Downstream water level/ Stroomafwaarts waterpeil (m)

### Villemonte Correctie

$$
Q_{corrected} = (Q_o + Q_u) \cdot \left[1 - \left(\frac{h_o}{h_{o2}}\right)^{3/2} \right]^{0.385}
$$ **Where:** - $Q_{corrected}$ = Adjusted discharge considering submergence/ Gecorrigeerde debiet submersie in beschouwing nemend(m³/s) - $h_{o2}$ = Reference head/ referentiehoogte (m)

### Vrije stroming

$$
Q_o = Q_{total} \cdot \left(\frac{h_o}{h_o + h_u}\right)
$$ **Waar:** - $Q_o$ = Discharge over the weir/ Debiet over de stuw (m³/s) - $Q_{total}$ = Total discharge/ Totaal debiet (m³/s) - $h_o$ = Head over the weir crest/ Waterhoogte boven de stuwkruin (m) - $h_u$ = Height of sluice opening/ Hoogte van de stuwopening (m)

$$
Q_u = Q_{total} \cdot \left(\frac{h_u}{h_o + h_u}\right)
$$ **Waar:** - $Q_u$ = Discharge under the weir/ Debiet onder de stuw (m³/s) - $Q_{total}$ = Total discharge/ Totaal debiet (m³/s) - $h_o$ = Head over the weir crest/ Waterhoogte boven de stuwkruin (m) - $h_u$ = Height of sluice opening/ Hoogte van de stuwopening (m)

### Stroomsnelheid

$$
V = \frac{Q}{A}
$$ **Waar:** - $V$ = Water velocity/ Waterstroomsnelheid (m/s) - $Q$ = Discharge/ Debiet (m³/s) - $A$ = Flow area/ Stromingsoppervlakte (m²) (Afhankelijk van of de stroming onder of over de stuw gaat)

# Resultaten

```{r}
# Load hourly water level data (replace 'data.csv' with actual file)
data <- data

# Assume columns: 'date_utc', 'h_upstream', 'h_downstream', 'sluice_opening'
# head(data)
```

```{r}
# Define Discharge Function
compute_discharge <- function(h_up, h_down, h_si, h_u, b, C_e = 1.7, C_d = 0.6, g = 9.81) {
  
  if (h_up < h_down) {
    flow="up"
  } else {
    flow="down"
  }
  
  if (flow=="down"){
    h_o <- h_up - h_si  # Effective head over weir
  
    # Weir Flow
    Q_o <- C_e * (2/3) * b * sqrt(2 * g) * (h_o^(3/2))
    
    # Sluice Flow (if gate is open)
    Q_u <- ifelse(h_u > 0, C_d * b * h_u * sqrt(2 * g * (h_up - h_down)), 0)
    
    # Apply Villemonte Correction if submerged
    if (h_down >= h_o) {
      Q_o <- Q_o * (1 - (h_o / h_down)^(3/2))^0.385
    } 
  }
  
  if (flow=="up"){
    h_o <- h_down - h_si  # Effective head over weir
  
    # Weir Flow
    Q_o <- C_e * (2/3) * b * sqrt(2 * g) * (h_o^(3/2))
    
    # Sluice Flow (if gate is open)
    Q_u <- ifelse(h_u > 0, C_d * b * h_u * sqrt(2 * g * (h_down - h_up)), 0)
    
    # Apply Villemonte Correction if submerged
    if (h_up >= h_o) {
      Q_o <- Q_o * (1 - (h_o / h_up)^(3/2))^0.385
    } 
    
    Q_o = Q_o * -1
    Q_u = Q_u * -1
  }
  
  # Compute Velocity (using total area depending on flow type)
  A_o <- b * h_o  # Cross-section for overflow
  A_u <- b * h_u  # Cross-section for underflow
  V_o <- ifelse(A_o > 0, Q_o / A_o, 0)
  V_u <- ifelse(A_u > 0, Q_u / A_u, 0)
  
  return(list(h_o = h_o, Q_o = Q_o, Q_u = Q_u, V_o = V_o, V_u = V_u))
}
```

```{r}
# Calculate Discharge for All Data
discharge_results <- mapply(compute_discharge, 
                            h_up = data$h_upstream, 
                            h_down = data$h_downstream, 
                            h_si = data$sluice_height,
                            h_u = data$sluice_opening, 
                            b = 17, 
                            SIMPLIFY = FALSE)

data <- data %>% 
  mutate(h_o = sapply(discharge_results, function(x) x$h_o),
         Q_o = sapply(discharge_results, function(x) x$Q_o),
         Q_u = sapply(discharge_results, function(x) x$Q_u),
         Q_total = rowSums(across(c(Q_o, Q_u)), na.rm = TRUE),
         V_o = sapply(discharge_results, function(x) x$V_o),
         V_u = sapply(discharge_results, function(x) x$V_u),
         )

#head(data)
```

```{r}
data <- data %>%
  mutate(
    freeflow_via_weir = case_when(
      h_downstream > sluice_height & h_upstream > sluice_height ~ "yes",
      TRUE ~ "no"
    ),
    freeflow_via_sluice = case_when(
      h_downstream < sluice_opening & h_upstream < sluice_opening ~ "yes",
      TRUE ~ "no"
    )
  )

# left_join data and waterinfo (loc==afvoer only) based on date_utc
data <- data %>%
  left_join(waterinfo %>% dplyr::filter(var == "afvoer") %>% dplyr::select(date_utc, value), by = "date_utc") %>%
  rename(Q_total_waterinfo = value)

# if freeflow_via_weir=="yes" then Q_o = Q_total_waterinfo and Q_total = Q_total_waterinfo and q_u = 0, if freeflow_via_sluice=="yes" then Q_u = Q_total_waterinfo and Q_total = Q_total_waterinfo and q_o = 0
# data <- data %>%
#   mutate(
#     Q_o = ifelse(freeflow_via_weir == "yes", Q_total_waterinfo, Q_o),
#     Q_u = ifelse(freeflow_via_sluice == "yes", Q_total_waterinfo, Q_u),
#     Q_total = ifelse(freeflow_via_weir == "yes" | freeflow_via_sluice == "yes", Q_total_waterinfo, Q_total),
#     V_o = ifelse(freeflow_via_weir == "yes", Q_total_waterinfo / (17 * h_o), V_o),
#     V_u = ifelse(freeflow_via_sluice == "yes", Q_total_waterinfo / (17 * sluice_opening), V_u)
#   )

data <- data %>%
  mutate(
    h_o_temp = ifelse(h_o<0, 0, h_o),
    sluice_opening_temp = ifelse(sluice_opening<0, 0, sluice_opening),
    Q_o = ifelse(freeflow_via_weir == "yes" | freeflow_via_sluice == "yes", Q_total_waterinfo*(h_o_temp/(h_o_temp+sluice_opening_temp)), Q_o),
    Q_u = ifelse(freeflow_via_sluice == "yes", Q_total_waterinfo*(sluice_opening_temp/(h_o_temp+sluice_opening_temp)), Q_u),
    Q_total = ifelse(freeflow_via_weir == "yes" | freeflow_via_sluice == "yes", Q_total_waterinfo, Q_total),
    V_o = ifelse(freeflow_via_weir == "yes" | freeflow_via_sluice == "yes", Q_o / (17 * h_o), V_o),
    V_u = ifelse(freeflow_via_sluice == "yes" | freeflow_via_sluice == "yes", Q_u / (17 * sluice_opening), V_u)
  )
```

## Tijdsreeksen

```{r fig.width=12, fig.height=20, out.width='100%', out.height='90%', fig.align='center', fig.cap="Tijdreeksen van waterhoogte en debiet. $h_downstream$ en $h_upstream$ zijn de waterhoogtes stroomafwaarts en stroomopwaarts van de stuw, $h_u$ is de hoogte van de stuwopening, $h_o$ is de waterhoogte boven de stuwkruin, $Q_o$ is het debiet over de stuw, $Q_u$ is het debiet onder de stuw."}
data %>%
  dplyr::select(-h_o_temp) %>%
  pivot_longer(
    cols = c(matches("^(h_|Q_)(?!total_waterinfo$)", perl = TRUE), sluice_opening),
    names_to = "variable",
    values_to = "value"
  ) %>%
  mutate(
    variable = if_else(variable == "sluice_opening", "h_u", variable)
  ) %>%
  ggplot(aes(x = date_utc, y = value)) +
  geom_line() +
  facet_wrap(~ variable, scales = "free_y", ncol = 1) +
  labs(
    x = "Datum", y = "Waarde"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    strip.text = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

```{r fig.width=12, fig.height=8, out.width='100%', fig.align='center', fig.cap="Tijdreeksen van debiet. $Q_o$ is het debiet over de stuw, $Q_u$ is het debiet onder de stuw."}
ggplot(data, aes(x = date_utc)) +
  geom_line(aes(y = Q_o, color = "Debiet over stuw (Q_o)")) +
  geom_line(aes(y = Q_u, color = "Debiet onder stuw (Q_u)")) +
  labs(y = "Debiet (m³/s)", x = "Tijd", color = NULL) +
  scale_color_manual(values = c("blue", "red")) + 
  theme_minimal(base_size = 18) +
  theme(
    legend.position = "bottom"  # move legend below
  )
  
```

```{r fig.width=12, fig.height=8, out.width='100%', fig.align='center', fig.cap="Tijdreeksen van waterstroomsnelheid. $V_o$ is de stroomsnelheid over de stuw, $V_u$ is de stroomsnelheid onder de stuw."}
ggplot(data %>% dplyr::filter(V_o<8), aes(x = date_utc)) +
  geom_line(aes(y = V_o, color = "Stroomsnelheid over stuw (V_o)")) +
  geom_line(aes(y = V_u, color = "Stroomsnelheid onder stuw (V_u)")) +
  labs(y = "Stroomsnelheid (m/s)", x = "Tijd", color = NULL) +
  scale_color_manual(values = c("green", "purple")) + 
  theme_minimal(base_size = 17) +
  theme(
    legend.position = "bottom"  # move legend below
  )
```

```{r}
data <- data %>%
  mutate(
    passeerbaar_stroomopwaarts_over_stuw = case_when(
      bereikbaar_stroomopwaarts_over_stuw == "yes" & V_o < 1 ~ "yes",
      TRUE ~ "no"
    ),
    passeerbaar_stroomopwaarts_onder_stuw = case_when(
      bereikbaar_onder_stuw == "yes" & V_u < 1 ~ "yes",
      TRUE ~ "no"
    ),
    passeerbaar_stroomopwaarts = case_when(
      passeerbaar_stroomopwaarts_over_stuw == "yes" | passeerbaar_stroomopwaarts_onder_stuw == "yes" ~ "yes",
      TRUE ~ "no"
    ),
    passeerbaar_stroomafwaarts_over_stuw = case_when(
      bereikbaar_stroomafwaarts_over_stuw == "yes" & V_o > -1 ~ "yes",
      TRUE ~ "no"
    ),
    passeerbaar_stroomafwaarts_onder_stuw = case_when(
      bereikbaar_onder_stuw == "yes" & V_u > -1 ~ "yes",
      TRUE ~ "no"
    ),
    passeerbaar_stroomafwaarts = case_when(
      passeerbaar_stroomafwaarts_over_stuw == "yes" | passeerbaar_stroomafwaarts_onder_stuw == "yes" ~ "yes",
      TRUE ~ "no"
    )
  )
```

```{r}
write.csv(data, file = "./data/intern/data.csv")
```

```{r}
data <- data %>%
  mutate(date = as_date(date_utc),
         month = month(date_utc, label = TRUE),
         year = year(date_utc))
```

## Tijdsaandeel bereikbaarheid en passeerbaarheid

```{r fig.width=12, fig.height=16, out.width='100%', fig.align='center'}
data %>%
  pivot_longer(
    cols = matches("^(bereikbaar|passeerbaar)_(via_)?(stroomopwaarts|stroomafwaarts)?"),
    names_to = "type",
    values_to = "status"
  ) %>%
  group_by(type) %>%
  summarise(
    totaal = n(),
    yes = sum(status == "yes", na.rm = TRUE),
    aandeel_yes = yes / totaal
  ) %>%
  mutate(
    group = if_else(str_detect(type, "^bereikbaar"), "Bereikbaar", "Passeerbaar"),
    type = fct_relevel(type,
                       sort(unique(type[str_detect(type, "^bereikbaar")])),
                       sort(unique(type[str_detect(type, "^passeerbaar")]))
    )
  ) %>%
  ggplot(aes(x = type, y = aandeel_yes, fill = group)) +
  geom_col() +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(
    title = "Bereikbaarheid en passeerbaarheid per route en richting",
    x = "Route × Richting", y = "Aandeel momenten",
    fill = "Categorie"
  ) +
  theme_minimal(base_size = 16) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r fig.width=12, fig.height=20, out.width='100%', fig.align='center'}
data %>%
  mutate(month = floor_date(as_date(date_utc), "month")) %>%
  pivot_longer(
    cols = matches("^(bereikbaar|passeerbaar)_(via_)?(stroomopwaarts|stroomafwaarts)?"),
    names_to = "type",
    values_to = "status"
  ) %>%
  group_by(type, month) %>%
  summarise(
    totaal = n(),
    yes = sum(status == "yes", na.rm = TRUE),
    aandeel_yes = yes / totaal,
    .groups = "drop"
  ) %>%
  mutate(
  month_label = format(month, "%B %Y"),
  month_label = str_to_sentence(month_label),
  month_label = factor(month_label, levels = unique(month_label[order(month)])),
  group = if_else(str_detect(type, "^bereikbaar"), "Bereikbaar", "Passeerbaar"),
  type = fct_relevel(type,
                     sort(unique(type[str_detect(type, "^bereikbaar")])),
                     sort(unique(type[str_detect(type, "^passeerbaar")]))
    )
  ) %>%
  ggplot(aes(x = type, y = aandeel_yes, fill = group)) +
  geom_col() +
  facet_wrap(~ month_label, ncol = 1) +  # gebruik nieuwe maand-labels
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, 1)) +
  labs(
    title = "Aandeel 'yes'-momenten per route × richting per maand",
    x = "Route × Richting", y = "Aandeel momenten",
    fill = "Categorie"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(face = "bold")
  )
```

```{r fig.width=12, fig.height=8, out.width='100%', fig.align='center'}
data %>%
  mutate(date = as.Date(date_utc)) %>%
  group_by(date) %>%
  summarise(
    doable_up = sum(passeerbaar_stroomopwaarts == "yes", na.rm = TRUE)/288,
    doable_down = sum(passeerbaar_stroomafwaarts == "yes", na.rm = TRUE)/288
  ) %>%
  pivot_longer(cols = c(doable_up, doable_down), names_to = "direction", values_to = "count") %>%
  mutate(direction = recode(direction,
                            "doable_up" = "Stroomopwaarts",
                            "doable_down" = "Stroomafwaarts")) %>%
  ggplot(aes(x = date, y = count, color = direction)) +
  geom_line() +
  labs(
    title = "Aandeel passeerbare momenten per dag per richting",
    x = "Datum", y = "Aandeel momenten (per dag)",
    color = "Richting"
  ) + 
  theme_minimal(base_size = 18)
```

```{r fig.width=12, fig.height=5, out.width='100%', fig.align='center'}
data %>%
  mutate(date = as.Date(date_utc)) %>%
  group_by(date) %>%
  summarise(
    up_onder_Stuw   = sum(passeerbaar_stroomopwaarts_onder_stuw == "yes", na.rm = TRUE)/288,
    up_over_Stuw    = sum(passeerbaar_stroomopwaarts_over_stuw == "yes", na.rm = TRUE)/288,
    down_onder_Stuw = sum(passeerbaar_stroomafwaarts_onder_stuw == "yes", na.rm = TRUE)/288,
    down_over_Stuw  = sum(passeerbaar_stroomafwaarts_over_stuw == "yes", na.rm = TRUE)/288
  ) %>%
  pivot_longer(
    cols = -date,
    names_to = "route_direction",
    values_to = "count"
  ) %>%
  separate(route_direction, into = c("direction", "route", "type"), sep = "_") %>%
  mutate(
    direction_label = recode(direction, "up" = "Stroomopwaarts", "down" = "Stroomafwaarts"),
    route_label = str_to_sentence(route),
    lijn = paste(route_label, "stuw"),
    groep = direction_label
  ) %>%
  ggplot(aes(x = date, y = count, color = lijn)) +
  geom_line(size = 1) +
  facet_wrap(~ groep, ncol = 2) +
  labs(
    title = "Aandeel passeerbare momenten per dag",
    x = "Datum", y = "Aandeel momenten",
    color = "Route"
  ) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_minimal(base_size = 16) +
  theme(
    strip.text = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

```{r fig.width=12, fig.height=5, out.width='100%', fig.align='center'}
data %>%
  mutate(date = as.Date(date_utc)) %>%
  group_by(date) %>%
  summarise(
    up_onder_Stuw   = sum(passeerbaar_stroomopwaarts_onder_stuw == "yes", na.rm = TRUE)/288,
    up_over_Stuw    = sum(passeerbaar_stroomopwaarts_over_stuw == "yes", na.rm = TRUE)/288,
    down_onder_Stuw = sum(passeerbaar_stroomafwaarts_onder_stuw == "yes", na.rm = TRUE)/288,
    down_over_Stuw  = sum(passeerbaar_stroomafwaarts_over_stuw == "yes", na.rm = TRUE)/288
  ) %>%
  pivot_longer(
    cols = -date,
    names_to = "route_direction",
    values_to = "count"
  ) %>%
  separate(route_direction, into = c("direction", "route", "type"), sep = "_") %>%
  mutate(
    direction_label = recode(direction, "up" = "Stroomopwaarts", "down" = "Stroomafwaarts"),
    route_label = str_to_sentence(route),
    lijn = direction_label,
    groep = paste(route_label, "Stuw")
  ) %>%
  ggplot(aes(x = date, y = count, color = lijn)) +
  geom_line(size = 1) +
  facet_wrap(~ groep, ncol = 2) +
  labs(
    title = "Aandeel passeerbare momenten per dag",
    x = "Datum", y = "Aandeel momenten",
    color = "Richting"
  ) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  theme_minimal(base_size = 16) +
  theme(
    strip.text = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

## Parameteranalyse

```{r correlation-plot, message=FALSE, warning=FALSE}
# Select only explanatory variables
vars <- c("h_downstream", "h_upstream", "h_o", "sluice_opening", "Q_total_waterinfo")

# Compute correlation matrix (pairwise complete obs to handle NAs)
cor_mat <- cor(data[vars], use = "pairwise.complete.obs", method = "pearson")

# Plot
corrplot(cor_mat, method = "color", type = "upper",
         addCoef.col = "black", # add correlation values
         tl.col = "black", tl.srt = 45, number.cex = 0.7)

```

### Stroomopwaartse passeerbaarheid over de stuw

#### Beslissingsboom

```{r roc_over_stuw, fig.width=6, fig.height=5}
# set.seed(123)

target_var <- "passeerbaar_stroomopwaarts_over_stuw"

# Voorbereiden
df_bal <- data %>%
  dplyr::filter(.data[[target_var]] %in% c("yes", "no")) %>%
  mutate(target = factor(.data[[target_var]], levels = c("no", "yes"))) %>%
  select(target, starts_with("h_"), starts_with("Q_"), sluice_opening, -Q_total, -Q_o, -Q_u) %>%
  group_by(target) %>%
  group_modify(~ slice_sample(.x, n = min(table(data[[target_var]])[c("yes", "no")]))) %>%
  ungroup()

# Split in train/test
split <- initial_split(df_bal, prop = 0.7, strata = target)
train_data <- training(split)
test_data <- testing(split)

# Train model
model <- rpart(target ~ ., data = train_data, method = "class", cp = 0.01, minbucket = 100)

rpart.plot(model)

# Predict probabilities
pred_probs <- predict(model, test_data, type = "prob")[, "yes"]
pred_class <- predict(model, test_data, type = "class")

# Combineer met testdata
pred_df <- bind_cols(test_data, .pred_yes = pred_probs)

# Bereken ROC
roc_df <- yardstick::roc_curve(pred_df, truth = target, .pred_yes)

# Plot
autoplot(roc_df) +
  ggtitle(paste("ROC-curve voor:", target_var)) +
  theme_minimal(base_size = 14)

cm <- confusionMatrix(pred_class, test_data$target, positive = "yes")
cm

ggplot(pred_df, aes(x = .pred_yes, fill = target)) +
  geom_histogram(position = "stack", alpha = 0.5, bins = 30)

# Suppose you have:
# y_true = actual labels (factor with levels "no", "yes")
# y_prob = predicted probability for "yes" class

y_true <- test_data$target
y_prob <- pred_probs

roc_obj <- roc(y_true, y_prob, levels = c("no", "yes"))

# Plot ROC
plot(roc_obj, col = "#1c61b6", lwd = 2, main = "ROC Curve with Threshold = 0.5 Marked")

# Find sensitivity/specificity at threshold 0.5
coords_05 <- coords(roc_obj, x = 0.5, input = "threshold", ret = c("specificity", "sensitivity"))

# Add point for threshold = 0.5
points(1 - coords_05["specificity"], coords_05["sensitivity"], 
       pch = 19, col = "red", cex = 1.5)

text(1 - coords_05["specificity"], coords_05["sensitivity"], 
     labels = "Threshold = 0.5", pos = 4, col = "red")
```

#### Random forest

```{r}
target_var <- "passeerbaar_stroomopwaarts_over_stuw"

# Filter to rows with no missing predictor values
df_train <- data %>%
  dplyr::filter(.data[[target_var]] %in% c("yes", "no")) %>%
  mutate(target = factor(.data[[target_var]], levels = c("no", "yes"))) %>%
  filter(!is.na(h_downstream), !is.na(h_upstream), !is.na(h_o),
         !is.na(sluice_opening), !is.na(Q_total_waterinfo),
         !is.na(passeerbaar_stroomopwaarts_over_stuw)) %>%
  group_by(target) %>%
  group_modify(~ slice_sample(.x, n = min(table(data[[target_var]])[c("yes", "no")]))) %>%
  ungroup()

set.seed(42)
rf_model <- randomForest(
  target ~ h_o + sluice_opening + h_downstream + h_upstream + Q_total_waterinfo,
  data = df_train,
  ntree = 500,
  mtry = 3,
  importance = TRUE
)

print(rf_model)

# Create grid
predict_grid <- expand.grid(
  h_downstream      = seq(min(df_train$h_downstream), max(df_train$h_downstream), length.out = 10),
  h_upstream        = seq(min(df_train$h_upstream), max(df_train$h_upstream), length.out = 10),
  h_o               = seq(min(df_train$h_o), max(df_train$h_o), length.out = 10),
  sluice_opening    = seq(min(df_train$sluice_opening), max(df_train$sluice_opening), length.out = 10),
  Q_total_waterinfo = seq(min(df_train$Q_total_waterinfo), max(df_train$Q_total_waterinfo), length.out = 10))

predict_grid$prob_yes <- predict(rf_model, newdata = predict_grid, type = "prob")[, "yes"]
```

```{r}
vars <- c("h_downstream", "h_upstream", "h_o", "sluice_opening", "Q_total_waterinfo")
pairs <- combn(vars, 2, simplify = FALSE)

# 1. Bepaal de globale min/max van prob_yes voor een consistente kleurschaal
global_min <- min(predict_grid$prob_yes, na.rm = TRUE)
global_max <- max(predict_grid$prob_yes, na.rm = TRUE)

# 2. Maak alle plots
plots <- map(pairs, function(p) {
  ggplot(predict_grid, aes_string(x = p[1], y = p[2], fill = "prob_yes")) +
    geom_tile() +
    scale_fill_viridis_c(name = "P(yes)", limits = c(global_min, global_max)) +
    labs(
      title = paste("Predicted passability probability\n(stroomopwaarts over stuw)"),
      subtitle = paste(p[1], "vs", p[2]),
      x = p[1],
      y = p[2]
    ) +
    theme_minimal(base_size = 14) +
    theme(plot.subtitle = element_text(face = "italic"))
})

# 3. Print plots apart in RMarkdown
for (pl in plots) {
  print(pl)
}
```

```{r eval=FALSE, warning=FALSE}
# Minimale waterhoogte boven stuw voor stroomopwaartse passage over stuw
data_ho <- data %>% dplyr::filter(h_upstream!=h_downstream)

ho_results <- mapply(estimate_parameters_with_solver_to_optimize_vo, 
                            Q_total = data_ho$Q_total_waterinfo, 
                            V_o_target = 0.99,
                            h_up = data_ho$h_upstream,
                            h_down = data_ho$h_downstream, 
                            #h_u = data_ho$sluice_opening,
                            h_u = 0, 
                            b = 17, 
                            SIMPLIFY = FALSE)

ho_results_df <- map_dfr(ho_results, as_tibble)
data_ho <- cbind(data_ho, ho_results_df)
```

```{r eval=FALSE}
# Create the plot using ggplot2
ggplot(data_ho, aes(x = h_o, y = h_o_required)) +
  # Add a horizontal line for the constant h_o_required value
  #geom_hline(yintercept = unique(data_ho$h_o_required), linetype = "solid", color = "blue", size = 1) +
  
  # Add a 1:1 reference line
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "gray", size = 0.5) +
  
  # Plot the data points, with color determined by the "passeerbaar" variable
  geom_point(aes(color = passeerbaar_stroomopwaarts_over_stuw), size = 3) +
  
  # Add labels and a title for clarity
  labs(
    title = "Comparison of Actual vs. Required Effective Head (h_o)",
    x = "Actual Effective Head (h_o)",
    y = "Required Effective Head (h_o_required)",
    color = "Passage Upstream"
  ) +
  
  # Set a clean theme
  theme_minimal()
```

#### Range waterhoogte boven stuw voor stroomopwaartse passage over stuw

```{r eval=FALSE, warning=FALSE}
data_ho <- data %>% dplyr::filter(h_upstream!=h_downstream)

ho_results <- mapply(find_optimal_ranges, 
                            Q_total = data_ho$Q_total_waterinfo, 
                            V_o_threshold = 0.99,
                            h_up = data_ho$h_upstream,
                            h_down = data_ho$h_downstream, 
                            b = 17, 
                            SIMPLIFY = FALSE)

ho_results_df <- map_dfr(ho_results, as_tibble)

```

```{r}
# Set the parameters for the plots
V_o_threshold <- 1
h_up <- 5.0
h_down <- 2.0
b <- 10.0
C_e <- 1.7
C_d <- 0.6
g <- 9.81

# Define the ranges for the plot variables
Q_total_values <- seq(from = 10, to = 90, by = 10)
h_o_values <- seq(from = 0.5, to = 3, by = 0.5)
h_u_range <- seq(from = 0, to = max(h_up, h_down), length.out = 100)

# Define the core velocity calculation function
get_vo <- function(h_o, h_u, Q_total) {
  if (h_o <= 0 || h_u < 0) return(NA_real_)
  
  flow = if (h_up < h_down) "up" else "down"
  
  if (flow == "down") {
    Q_u <- ifelse(h_u > 0, C_d * b * h_u * sqrt(2 * g * (h_up - h_down)), 0)
  } else {
    Q_u <- ifelse(h_u > 0, C_d * b * h_u * sqrt(2 * g * (h_down - h_up)), 0)
    Q_u <- Q_u * -1
  }
  
  Q_o_calc <- Q_total - Q_u
  
  if (Q_o_calc <= 0) return(NA_real_)
  
  V_o_calc <- Q_o_calc / (b * h_o)
  return(V_o_calc)
}

# Create a data frame for plotting
plot_data <- data.frame()

for (Q_total_val in Q_total_values) {
  for (h_o_val in h_o_values) {
    temp_df <- data.frame(
      h_u = h_u_range,
      V_o = sapply(h_u_range, get_vo, h_o = h_o_val, Q_total = Q_total_val),
      h_o = as.factor(h_o_val),
      Q_total = as.factor(Q_total_val)
    )
    plot_data <- rbind(plot_data, temp_df)
  }
}

# Plot the results using facets for Q_total
ggplot(plot_data, aes(x = h_u, y = V_o, color = h_o)) +
  geom_line(size = 1) +
  geom_hline(yintercept = V_o_threshold, linetype = "dashed", color = "black") +
  facet_wrap(~ Q_total, scales = "free_y") +
  labs(
    title = "Effect of Sluice Opening on Overflow Velocity for Different Total Discharges (m³/s)",
    x = "Sluice Gate Opening (m)",
    y = "Overflow Velocity (m/s)",
    color = "Effective Head (m)"
  ) +
  xlim(0,2) +
  theme_minimal()
```

```{r eval=FALSE}
# Minimale combinaties van waterhoogte onder en boven stuw voor stroomopwaartse passage over stuw
Q_total_known <- data$Q_total_waterinfo[1]    # Total discharge (m3/s)
V_o_target_limit <- 0.99  # Target overflow velocity (m/s)
h_up_level <- data$h_upstream[1]     # Upstream water level (m)
h_down_level <- data$h_downstream[1]   # Downstream water level (m)
width_b <- 17       # Weir width (m)

# Find all possible combinations
solutions <- find_parameter_combinations_to_optimize_vo(
  Q_total = Q_total_known,
  V_o_target = V_o_target_limit,
  h_up = h_up_level,
  h_down = h_down_level,
  b = width_b
)

# Display the solutions
print(solutions)
```

### Stroomopwaartse passeerbaarheid onder de stuw

#### Beslissingsboom

```{r roc_onder_stuw, fig.width=6, fig.height=5}
# set.seed(123)

target_var <- "passeerbaar_stroomopwaarts_onder_stuw"

# Voorbereiden
df_bal <- data %>%
  dplyr::filter(.data[[target_var]] %in% c("yes", "no")) %>%
  mutate(target = factor(.data[[target_var]], levels = c("no", "yes"))) %>%
  select(target, starts_with("h_"), starts_with("Q_"), sluice_opening, -Q_total, -Q_o, -Q_u) %>%
  group_by(target) %>%
  group_modify(~ slice_sample(.x, n = min(table(data[[target_var]])[c("yes", "no")]))) %>%
  ungroup()

# Split in train/test
split <- initial_split(df_bal, prop = 0.7, strata = target)
train_data <- training(split)
test_data <- testing(split)

# Train model
model <- rpart(target ~ ., data = train_data, method = "class", cp = 0.01, minbucket = 200)

rpart.plot(model)

# Predict probabilities
pred_probs <- predict(model, test_data, type = "prob")[, "yes"]
pred_class <- predict(model, test_data, type = "class")

# Combineer met testdata
pred_df <- bind_cols(test_data, .pred_yes = pred_probs)

# Bereken ROC
roc_df <- yardstick::roc_curve(pred_df, truth = target, .pred_yes)

# Plot
autoplot(roc_df) +
  ggtitle(paste("ROC-curve voor:", target_var)) +
  theme_minimal(base_size = 14)

cm <- confusionMatrix(pred_class, test_data$target, positive = "yes")
cm

ggplot(pred_df, aes(x = .pred_yes, fill = target)) +
  geom_histogram(position = "stack", alpha = 0.5, bins = 50)

# Suppose you have:
# y_true = actual labels (factor with levels "no", "yes")
# y_prob = predicted probability for "yes" class

y_true <- test_data$target
y_prob <- pred_probs

roc_obj <- roc(y_true, y_prob, levels = c("no", "yes"))

# Plot ROC
plot(roc_obj, col = "#1c61b6", lwd = 2, main = "ROC Curve with Threshold = 0.5 Marked")

# Find sensitivity/specificity at threshold 0.5
coords_05 <- coords(roc_obj, x = 0.5, input = "threshold", ret = c("specificity", "sensitivity"))

# Add point for threshold = 0.5
points(1 - coords_05["specificity"], coords_05["sensitivity"], 
       pch = 19, col = "red", cex = 1.5)

text(1 - coords_05["specificity"], coords_05["sensitivity"], 
     labels = "Threshold = 0.5", pos = 4, col = "red")
```

#### Random forest

```{r}
target_var <- "passeerbaar_stroomopwaarts_onder_stuw"

# Filter to rows with no missing predictor values
df_train <- data %>%
  dplyr::filter(.data[[target_var]] %in% c("yes", "no")) %>%
  mutate(target = factor(.data[[target_var]], levels = c("no", "yes"))) %>%
  filter(!is.na(h_downstream), !is.na(h_upstream), !is.na(h_o),
         !is.na(sluice_opening), !is.na(Q_total_waterinfo),
         !is.na(passeerbaar_stroomopwaarts_over_stuw)) %>%
  group_by(target) %>%
  group_modify(~ slice_sample(.x, n = min(table(data[[target_var]])[c("yes", "no")]))) %>%
  ungroup()

set.seed(42)
rf_model <- randomForest(
  target ~ h_o + sluice_opening + h_downstream + h_upstream + Q_total_waterinfo,
  data = df_train,
  ntree = 500,
  mtry = 3,
  importance = TRUE
)

print(rf_model)

# Create grid
predict_grid <- expand.grid(
  h_downstream      = seq(min(df_train$h_downstream), max(df_train$h_downstream), length.out = 10),
  h_upstream        = seq(min(df_train$h_upstream), max(df_train$h_upstream), length.out = 10),
  h_o               = seq(min(df_train$h_o), max(df_train$h_o), length.out = 10),
  sluice_opening    = seq(min(df_train$sluice_opening), max(df_train$sluice_opening), length.out = 10),
  Q_total_waterinfo = seq(min(df_train$Q_total_waterinfo), max(df_train$Q_total_waterinfo), length.out = 10))

predict_grid$prob_yes <- predict(rf_model, newdata = predict_grid, type = "prob")[, "yes"]
```

```{r}
vars <- c("h_downstream", "h_upstream", "h_o", "sluice_opening", "Q_total_waterinfo")
pairs <- combn(vars, 2, simplify = FALSE)

# 1. Bepaal de globale min/max van prob_yes voor een consistente kleurschaal
global_min <- min(predict_grid$prob_yes, na.rm = TRUE)
global_max <- max(predict_grid$prob_yes, na.rm = TRUE)

# 2. Maak alle plots
plots <- map(pairs, function(p) {
  ggplot(predict_grid, aes_string(x = p[1], y = p[2], fill = "prob_yes")) +
    geom_tile() +
    scale_fill_viridis_c(name = "P(yes)", limits = c(global_min, global_max)) +
    labs(
      title = paste("Predicted passability probability\n(stroomopwaarts over stuw)"),
      subtitle = paste(p[1], "vs", p[2]),
      x = p[1],
      y = p[2]
    ) +
    theme_minimal(base_size = 14) +
    theme(plot.subtitle = element_text(face = "italic"))
})

# 3. Print plots apart in RMarkdown
for (pl in plots) {
  print(pl)
}
```

#### Range opening onder stuw voor stroomopwaartse passage onder stuw
